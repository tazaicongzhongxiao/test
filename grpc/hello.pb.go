// Code generated by protoc-gen-go. DO NOT EDIT.
// source: hello.proto

package test

import (
	context "context"
	json "encoding/json"
	fmt "fmt"
	tars "github.com/TarsCloud/TarsGo/tars"
	model "github.com/TarsCloud/TarsGo/tars/model"
	requestf "github.com/TarsCloud/TarsGo/tars/protocol/res/requestf"
	current "github.com/TarsCloud/TarsGo/tars/util/current"
	tools "github.com/TarsCloud/TarsGo/tars/util/tools"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ReqHello struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReqHello) Reset()         { *m = ReqHello{} }
func (m *ReqHello) String() string { return proto.CompactTextString(m) }
func (*ReqHello) ProtoMessage()    {}
func (*ReqHello) Descriptor() ([]byte, []int) {
	return fileDescriptor_61ef911816e0a8ce, []int{0}
}

func (m *ReqHello) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReqHello.Unmarshal(m, b)
}
func (m *ReqHello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReqHello.Marshal(b, m, deterministic)
}
func (m *ReqHello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqHello.Merge(m, src)
}
func (m *ReqHello) XXX_Size() int {
	return xxx_messageInfo_ReqHello.Size(m)
}
func (m *ReqHello) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqHello.DiscardUnknown(m)
}

var xxx_messageInfo_ReqHello proto.InternalMessageInfo

func (m *ReqHello) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ResHello struct {
	Greeting             string   `protobuf:"bytes,1,opt,name=greeting,proto3" json:"greeting,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResHello) Reset()         { *m = ResHello{} }
func (m *ResHello) String() string { return proto.CompactTextString(m) }
func (*ResHello) ProtoMessage()    {}
func (*ResHello) Descriptor() ([]byte, []int) {
	return fileDescriptor_61ef911816e0a8ce, []int{1}
}

func (m *ResHello) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResHello.Unmarshal(m, b)
}
func (m *ResHello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResHello.Marshal(b, m, deterministic)
}
func (m *ResHello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResHello.Merge(m, src)
}
func (m *ResHello) XXX_Size() int {
	return xxx_messageInfo_ResHello.Size(m)
}
func (m *ResHello) XXX_DiscardUnknown() {
	xxx_messageInfo_ResHello.DiscardUnknown(m)
}

var xxx_messageInfo_ResHello proto.InternalMessageInfo

func (m *ResHello) GetGreeting() string {
	if m != nil {
		return m.Greeting
	}
	return ""
}

func init() {
	proto.RegisterType((*ReqHello)(nil), "test.reqHello")
	proto.RegisterType((*ResHello)(nil), "test.resHello")
}

func init() { proto.RegisterFile("hello.proto", fileDescriptor_61ef911816e0a8ce) }

var fileDescriptor_61ef911816e0a8ce = []byte{
	// 127 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0xce, 0x48, 0xcd, 0xc9,
	0xc9, 0xd7, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x29, 0x49, 0x2d, 0x2e, 0x51, 0x92, 0xe3,
	0xe2, 0x28, 0x4a, 0x2d, 0xf4, 0x00, 0x89, 0x0b, 0x09, 0x71, 0xb1, 0xe4, 0x25, 0xe6, 0xa6, 0x4a,
	0x30, 0x2a, 0x30, 0x6a, 0x70, 0x06, 0x81, 0xd9, 0x4a, 0x6a, 0x20, 0xf9, 0x62, 0x88, 0xbc, 0x14,
	0x17, 0x47, 0x7a, 0x51, 0x6a, 0x6a, 0x49, 0x66, 0x5e, 0x3a, 0x54, 0x0d, 0x9c, 0x6f, 0x64, 0xcc,
	0xc5, 0x1c, 0x9c, 0x58, 0x29, 0xa4, 0xc3, 0xc5, 0x11, 0x9c, 0x58, 0x09, 0x51, 0xce, 0xa7, 0x07,
	0xb2, 0x41, 0x0f, 0x66, 0xbc, 0x14, 0x9c, 0x0f, 0x31, 0x4e, 0x89, 0x21, 0x89, 0x0d, 0xec, 0x12,
	0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x16, 0x78, 0x6a, 0x29, 0x98, 0x00, 0x00, 0x00,
}

// This following code was generated by tarsrpc
// Gernerated from hello.proto
type Say struct {
	servant model.Servant
}

// SetServant is required by the servant interface.
func (obj *Say) SetServant(servant model.Servant) {
	obj.servant = servant
}

// AddServant is required by the servant interface
func (obj *Say) AddServant(imp PBSayServant, objStr string) {
	tars.AddServant(obj, imp, objStr)
}

// AddServantWithContext adds servant  for the service with context
func (obj *Say) AddServantWithContext(imp PBSayServantWithContext, objStr string) {
	tars.AddServantWithContext(obj, imp, objStr)
}

// TarsSetTimeout is required by the servant interface. t is the timeout in ms.
func (obj *Say) TarsSetTimeout(t int) {
	obj.servant.TarsSetTimeout(t)
}

// TarsSetProtocol is required by the servant interface. t is the protocol.
func (obj *Say) TarsSetProtocol(p model.Protocol) {
	obj.servant.TarsSetProtocol(p)
}

type PBSayServant interface {
	SayHello(input ReqHello) (output ResHello, err error)
}

type PBSayServantWithContext interface {
	SayHello(ctx context.Context, input ReqHello) (output ResHello, err error)
}

// Dispatch is used to call the user implement of the defined method.
func (obj *Say) Dispatch(ctx context.Context, val interface{}, req *requestf.RequestPacket, resp *requestf.ResponsePacket, withContext bool) (err error) {
	input := tools.Int8ToByte(req.SBuffer)
	var output []byte
	funcName := req.SFuncName
	switch funcName {

	case "SayHello":
		inputDefine := ReqHello{}
		if err = proto.Unmarshal(input, &inputDefine); err != nil {
			return err
		}
		var res ResHello
		if !withContext {
			imp := val.(PBSayServant)
			res, err = imp.SayHello(inputDefine)
			if err != nil {
				return err
			}
		} else {
			imp := val.(PBSayServantWithContext)
			res, err = imp.SayHello(ctx, inputDefine)
			if err != nil {
				return err
			}
		}
		output, err = proto.Marshal(&res)
		if err != nil {
			return err
		}

	default:
		return fmt.Errorf("func mismatch")
	}
	var statusMap map[string]string
	if status, ok := current.GetResponseStatus(ctx); ok && status != nil {
		statusMap = status
	}
	var contextMap map[string]string
	if ctx, ok := current.GetResponseContext(ctx); ok && ctx != nil {
		contextMap = ctx
	}
	*resp = requestf.ResponsePacket{
		IVersion:     1,
		CPacketType:  0,
		IRequestId:   req.IRequestId,
		IMessageType: 0,
		IRet:         0,
		SBuffer:      tools.ByteToInt8(output),
		Status:       statusMap,
		SResultDesc:  "",
		Context:      contextMap,
	}
	return nil
}

// Change proto json 数据格式转换
func (obj *Say) Change(funcName string, val []byte, isRes bool) (output []byte, err error) {
	switch funcName {
	case "SayHello":
		if !isRes {
			req := ReqHello{}
			err = json.Unmarshal(val, &req)
			if err == nil {
				output, err = proto.Marshal(&req)
			}
		} else {
			res := ResHello{}
			err = proto.Unmarshal(val, &res)
			if err == nil {
				output, err = json.Marshal(&res)
			}
		}
	default:
		return nil, fmt.Errorf("func mismatch")
	}
	return output, err
}

// SayHello is client rpc method as defined
func (obj *Say) SayHello(input ReqHello, opts ...map[string]string) (output ResHello, err error) {
	ctx := context.Background()
	return obj.SayHelloWithContext(ctx, input, opts...)
}

// SayHelloWithContext is client rpc method as defined
func (obj *Say) SayHelloWithContext(ctx context.Context, input ReqHello, opts ...map[string]string) (output ResHello, err error) {
	var inputMarshal []byte
	inputMarshal, err = proto.Marshal(&input)
	if err != nil {
		return output, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	resp := new(requestf.ResponsePacket)
	err = obj.servant.TarsInvoke(ctx, 0, "SayHello", inputMarshal, statusMap, contextMap, resp)
	if err != nil {
		return output, err
	}
	if err = proto.Unmarshal(tools.Int8ToByte(resp.SBuffer), &output); err != nil {
		return output, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range resp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range resp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range resp.Status {
			statusMap[k] = v
		}
	}
	return output, nil
}
